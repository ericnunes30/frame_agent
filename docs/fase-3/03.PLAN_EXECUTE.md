# Implementação do Padrão Plan+Execute

## Visão Geral

O padrão Plan+Execute é uma abordagem avançada para resolver tarefas complexas que requerem múltiplos passos e tomada de decisão. Este padrão permite que os agentes decomponham problemas complexos em sub-tarefas menores, planejem a ordem de execução e coordenem a execução dessas tarefas.

## Conceito do Padrão

### Planejamento (Plan)
- Análise da tarefa complexa
- Decomposição em sub-tarefas
- Definição de dependências entre tarefas
- Criação de um plano de execução

### Execução (Execute)
- Execução coordenada das sub-tarefas
- Gerenciamento de dependências
- Tratamento de falhas e retries
- Agregação de resultados

## Interface de ExecutionPlan

```typescript
interface ExecutionPlan {
  taskId: string;
  description: string;
  steps: ExecutionStep[];
  dependencies: Record<string, string[]>;
  context: Record<string, any>;
  expectedResult: string;
}

interface ExecutionStep {
  id: string;
  description: string;
  toolName?: string;
  toolArgs?: any;
  subPlan?: ExecutionPlan;
  expectedOutput: string;
  dependencies: string[];
  retryCount?: number;
  maxRetries?: number;
}
```

## Componentes do Sistema

### 1. Task Planner

Responsável por analisar tarefas complexas e criar planos de execução:

```typescript
class TaskPlanner {
  private bamlClient: BamlClient;
  
  async plan(task: string, context: any): Promise<ExecutionPlan> {
    // Chamar BAML para gerar plano
    const planResponse = await this.bamlClient.GenerateExecutionPlan({
      task,
      context: JSON.stringify(context)
    });
    
    return this.parsePlan(planResponse);
  }
  
  private parsePlan(response: any): ExecutionPlan {
    // Parse e valida o plano retornado pelo LLM
    // Implementa lógica de validação
  }
  
  async decompose(task: string, context: any): Promise<ExecutionStep[]> {
    // Decompõe uma tarefa em etapas menores
    const decompositionResponse = await this.bamlClient.DecomposeTask({
      task,
      context: JSON.stringify(context)
    });
    
    return this.parseSteps(decompositionResponse);
  }
}
```

### 2. Plan Executor

Responsável por executar os planos de forma coordenada:

```typescript
class PlanExecutor {
  private toolRegistry: ToolRegistry;
  private maxParallelSteps: number = 5;
  
  async execute(plan: ExecutionPlan): Promise<PlanResult> {
    const results: Record<string, any> = {};
    const executionOrder = this.determineExecutionOrder(plan);
    
    for (const stepId of executionOrder) {
      const step = plan.steps.find(s => s.id === stepId);
      if (!step) continue;
      
      // Verificar dependências
      if (!this.checkDependencies(step, results)) {
        throw new Error(`Dependências não satisfeitas para o passo ${stepId}`);
      }
      
      try {
        const result = await this.executeStep(step, results);
        results[stepId] = result;
      } catch (error) {
        const recoveryAction = await this.handleFailure(step, error);
        if (recoveryAction === 'abort') {
          throw error;
        }
        // Implementar retry ou fallback
      }
    }
    
    return this.aggregateResults(results, plan);
  }
  
  private async executeStep(step: ExecutionStep, context: Record<string, any>): Promise<any> {
    if (step.toolName) {
      // Executar tool
      return await this.toolRegistry.execute(step.toolName, step.toolArgs);
    } else if (step.subPlan) {
      // Executar sub-plano
      return await this.execute(step.subPlan);
    } else {
      throw new Error(`Passo ${step.id} não tem tool nem sub-plano definido`);
    }
  }
  
  private determineExecutionOrder(plan: ExecutionPlan): string[] {
    // Implementar algoritmo de ordenação topológica
    // para respeitar dependências entre passos
  }
  
  private checkDependencies(step: ExecutionStep, results: Record<string, any>): boolean {
    return step.dependencies.every(depId => results.hasOwnProperty(depId));
  }
  
  private async handleFailure(step: ExecutionStep, error: Error): Promise<RecoveryAction> {
    // Implementar lógica de tratamento de falhas
    // Retry, fallback, abort, etc.
  }
}
```

## Integração com o Agente

### Extensão da Classe ChatAgent

```typescript
class MultiStepAgent extends ChatAgent {
  private planner: TaskPlanner;
  private executor: PlanExecutor;
  
  async planTask(task: string): Promise<ExecutionPlan> {
    const context = {
      history: this.getHistory(),
      variables: this.getAllContextVariables(),
      tools: this.listTools().map(t => ({ name: t.name, description: t.description }))
    };
    
    return await this.planner.plan(task, context);
  }
  
  async executePlan(plan: ExecutionPlan): Promise<PlanResult> {
    try {
      const result = await this.executor.execute(plan);
      
      // Adicionar resultado ao histórico
      this.memoryManager.addMessage({
        role: 'assistant',
        content: `Plano executado com sucesso. Resultado: ${JSON.stringify(result)}`
      });
      
      // Persistir estado se configurado
      if (this.persistenceManager) {
        await this.persistenceManager.save(this.getCurrentState());
      }
      
      return result;
    } catch (error) {
      this.memoryManager.addMessage({
        role: 'assistant',
        content: `Falha na execução do plano: ${error.message}`
      });
      
      throw error;
    }
  }
  
  async sendComplexMessage(message: string): Promise<string | PlanResult> {
    // Primeiro tentar resposta direta
    try {
      const directResponse = await super.sendMessage(message);
      return directResponse;
    } catch (error) {
      // Se falhar, tentar planejar e executar
      const plan = await this.planTask(message);
      const result = await this.executePlan(plan);
      return result;
    }
  }
}
```

## Exemplos de Uso

### 1. Pesquisa e Análise

```typescript
const agent = new MultiStepAgent({
  name: "Pesquisador",
  instructions: "Você é um assistente especializado em pesquisa e análise",
  provider: "openai-generic"
});

// Registrar tools de pesquisa
agent.registerTool(webSearchTool);
agent.registerTool(documentReaderTool);
agent.registerTool(analyzerTool);

// Tarefa complexa
const task = "Compare as estratégias de IA de Google, Microsoft e OpenAI nos últimos 2 anos";

const plan = await agent.planTask(task);
console.log("Plano gerado:", plan);

const result = await agent.executePlan(plan);
console.log("Resultado:", result);
```

### 2. Geração de Conteúdo Estruturado

```typescript
const agent = new MultiStepAgent({
  name: "Criador de Conteúdo",
  instructions: "Você é um assistente especializado em criar conteúdo estruturado",
  provider: "openai-generic"
});

// Registrar tools de criação de conteúdo
agent.registerTool(outlineGeneratorTool);
agent.registerTool(contentWriterTool);
agent.registerTool(editorTool);

// Tarefa complexa
const task = "Escreva um artigo técnico sobre 'Agentes de IA com BAML'";

const plan = await agent.planTask(task);
const result = await agent.executePlan(plan);

console.log("Artigo gerado:", result.finalContent);
```

## Considerações de Implementação

### 1. Complexidade do Planejamento
- O planejamento pode ser custoso em termos de tokens
- É importante balancear detalhe do plano com custo
- Pode ser necessário planejar em etapas

### 2. Gerenciamento de Estado
- Cada passo do plano deve atualizar o contexto
- Resultados intermediários devem ser armazenados
- Mecanismos de checkpoint para retomada

### 3. Tratamento de Falhas
- Implementar retries com backoff exponencial
- Fallback para abordagens alternativas
- Logging detalhado para debugging

### 4. Performance
- Executar passos independentes em paralelo
- Caching de resultados intermediários
- Limites de tempo para execução de planos

## Próximos Passos

1. Implementar protótipo do Task Planner
2. Criar Plan Executor básico
3. Desenvolver exemplos de tarefas complexas
4. Testar integração com tools existentes
5. Adicionar tratamento avançado de erros
6. Implementar execução paralela de passos
7. Documentar padrões de uso