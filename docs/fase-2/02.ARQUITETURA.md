# Arquitetura para Suporte a Tools

## Evolução da Arquitetura Atual

A arquitetura atual precisa ser expandida para suportar tools/funções de forma eficiente:

```
Construtor de Agentes (TypeScript) - Fase 2
│
├── Entrada: Configuração (instruções, modelo, tools, schema)
├── Saída: Instância de Agente
│
├── Agente:
│   ├── Estado: Histórico + variáveis + contexto
│   ├── Configuração: Modelo, temperatura, parâmetros
│   ├── Tools: Registro e gerenciamento de ferramentas
│   ├── Método: .perguntar(input) → resposta
│   ├── Método: .executarTool(toolName, args) → resultado
│   ├── Método: .resetar()
│   └── Método: .obterContexto()
│
├── Ciclo (com tools):
│   input → contexto → BAML → resposta/tool → 
│   se tool_calls:
│     → Executar tools → Adicionar resultados ao contexto → BAML
│   se resposta final:
│     → Adicionar ao histórico → Retornar ao usuário
│
├── Integração com BAML:
│   - Chamada com mensagens, tools registradas, schema
│   - Tratamento de tool_calls e execução
│   - Validação de saídas com schemas
│   - Suporte a streaming (opcional)
│
├── Sistema de Tools:
│   - Registro de tools com interface padrão
│   - Execução assíncrona de tools
│   - Tratamento de erros em tools
│   - Timeout e limites de execução
│
├── Memória de Contexto:
│   - Janela de contexto configurável
│   - Estratégias de seleção de mensagens
│   - Persistência de informações relevantes
│
├── Configuração Dinâmica:
│   - Parâmetros por chamada
│   - Perfis de configuração
│   - Validação de parâmetros
│
└── Testes:
    - Unitários para cada componente
    - Integração com tools reais
    - Testes de borda e erro
```

## Componentes Principais da Nova Arquitetura

### 1. Interface de Tool Padrão

```typescript
interface Tool {
  name: string;
  description: string;
  parameters?: z.ZodSchema | BAML Schema;
  execute: (args: any) => Promise<any>;
}
```

### 2. Sistema de Registro de Tools

```typescript
class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  
  register(tool: Tool): void;
  get(name: string): Tool | undefined;
  list(): Tool[];
  unregister(name: string): boolean;
}
```

### 3. Agente com Suporte a Tools

```typescript
class ChatAgent {
  private config: AgentConfig;
  private history: Message[] = [];
  private context: Map<string, any> = new Map();
  private tools: ToolRegistry;
  private memoryManager: MemoryManager;
  
  // Métodos existentes
  async sendMessage(message: string): Promise<string>;
  reset(): void;
  getHistory(): Message[];
  
  // Novos métodos
  registerTool(tool: Tool): void;
  executeTool(toolName: string, args: any): Promise<any>;
  setConfig(config: Partial<AgentConfig>): void;
  getContext(): Map<string, any>;
}
```

### 4. Gerenciador de Memória

```typescript
class MemoryManager {
  private contextWindow: number;
  private strategy: MemoryStrategy;
  
  addMessage(message: Message): void;
  getContext(): Message[];
  clear(): void;
  prune(): void;
}
```

### 5. Integração com BAML para Tools

```
// Definição de tools no BAML
function ProcessWithTools(history: ChatHistory, newMessage: string) -> string {
  client OpenAIGPT4oMini
  tools [CalculatorTool, DateTimeTool, WeatherTool]
  prompt #"
    Process the user message with available tools when needed.
    
    History:
    {% for message in history.messages %}
    {{ message.role }}: {{ message.content }}
    {% endfor %}
    
    New message: {{ newMessage }}
    
    {{ ctx.output_format }}
  "#
}
```

## Fluxo de Execução Expandido

1. **Inicialização**
   - Criar agente com configuração
   - Registrar tools necessárias
   - Configurar memória de contexto

2. **Envio de Mensagem**
   - Adicionar mensagem ao histórico
   - Preparar contexto com histórico + tools
   - Chamar função BAML com tools registradas

3. **Processamento de Resposta**
   - Se tool_calls:
     → Executar cada tool em paralelo
     → Adicionar resultados ao contexto
     → Chamar BAML novamente
   - Se resposta final:
     → Adicionar ao histórico
     → Retornar ao usuário

4. **Gerenciamento de Contexto**
   - Manter janela de contexto otimizada
   - Persistir informações importantes
   - Limpar contexto antigo quando necessário

## Considerações de Design

### 1. Extensibilidade
- Interface de tool padronizada permite fácil adição
- Sistema de plugins para tools complexas
- Suporte a tools síncronas e assíncronas

### 2. Segurança
- Validação de parâmetros de tools
- Timeout para execução de tools
- Limites de recursão para evitar loops infinitos

### 3. Performance
- Execução paralela de tools independentes
- Cache de resultados de tools quando apropriado
- Pruning inteligente do histórico de mensagens

### 4. Tratamento de Erros
- Mecanismos de retry para tools falhas
- Fallback quando tools não estão disponíveis
- Logging detalhado para debugging

## Próximos Passos

1. Implementar interface de Tool padrão
2. Criar sistema de registro de tools
3. Desenvolver gerenciador de memória
4. Integrar tools com BAML
5. Testar fluxo completo com tools simuladas
6. Documentar cada componente em detalhes