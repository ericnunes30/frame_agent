# Gerenciamento de Memória de Contexto

## Visão Geral

O gerenciamento de memória de contexto é crucial para agentes que mantêm conversas longas ou processam informações complexas. A memória de curto prazo permite que o agente mantenha contexto relevante entre interações, melhorando a coerência e a qualidade das respostas.

## Estratégias de Gerenciamento de Contexto

### 1. Janela de Contexto Fixa

```typescript
class FixedWindowMemory {
  private messages: Message[] = [];
  private windowSize: number;
  
  constructor(windowSize: number = 10) {
    this.windowSize = windowSize;
  }
  
  addMessage(message: Message): void {
    this.messages.push(message);
    if (this.messages.length > this.windowSize) {
      this.messages.shift(); // Remove a mensagem mais antiga
    }
  }
  
  getContext(): Message[] {
    return [...this.messages];
  }
  
  clear(): void {
    this.messages = [];
  }
}
```

### 2. Janela de Contexto Dinâmica

```typescript
class DynamicWindowMemory {
  private messages: Message[] = [];
  private maxTokens: number;
  private tokenizer: Tokenizer;
  
  constructor(maxTokens: number = 4096) {
    this.maxTokens = maxTokens;
    this.tokenizer = new Tokenizer(); // Implementação do tokenizer
  }
  
  addMessage(message: Message): void {
    this.messages.push(message);
    this.pruneToFit();
  }
  
  private pruneToFit(): void {
    while (this.getTokenCount() > this.maxTokens && this.messages.length > 1) {
      this.messages.shift();
    }
  }
  
  private getTokenCount(): number {
    return this.messages.reduce((total, msg) => 
      total + this.tokenizer.countTokens(msg.content), 0);
  }
  
  getContext(): Message[] {
    return [...this.messages];
  }
  
  clear(): void {
    this.messages = [];
  }
}
```

### 3. Seleção Inteligente de Contexto

```typescript
class SmartContextMemory {
  private messages: Message[] = [];
  private summary: string = "";
  private maxMessages: number;
  
  constructor(maxMessages: number = 20) {
    this.maxMessages = maxMessages;
  }
  
  addMessage(message: Message): void {
    this.messages.push(message);
    
    if (this.messages.length > this.maxMessages) {
      // Sumarizar mensagens antigas
      this.summarizeOldMessages();
    }
  }
  
  private async summarizeOldMessages(): Promise<void> {
    const messagesToSummarize = this.messages.slice(0, Math.floor(this.messages.length / 2));
    const recentMessages = this.messages.slice(Math.floor(this.messages.length / 2));
    
    // Chamar BAML para sumarizar
    try {
      const summary = await b.SummarizeConversation({
        messages: messagesToSummarize
      });
      
      this.summary = summary;
      this.messages = [
        { role: 'system', content: `Resumo da conversa anterior: ${summary}` },
        ...recentMessages
      ];
    } catch (error) {
      // Se falhar, apenas remover mensagens antigas
      this.messages = recentMessages;
    }
  }
  
  getContext(): Message[] {
    return [...this.messages];
  }
  
  clear(): void {
    this.messages = [];
    this.summary = "";
  }
}
```

## Estratégias de Pruning

### 1. Remoção por Idade

```typescript
class AgeBasedPruning {
  pruneByAge(messages: Message[], maxAgeMinutes: number): Message[] {
    const cutoffTime = Date.now() - (maxAgeMinutes * 60 * 1000);
    return messages.filter(msg => 
      new Date(msg.timestamp || Date.now()).getTime() > cutoffTime
    );
  }
}
```

### 2. Remoção por Relevância

```typescript
class RelevanceBasedPruning {
  async pruneByRelevance(
    messages: Message[],
    currentQuery: string,
    maxMessages: number
  ): Promise<Message[]> {
    if (messages.length <= maxMessages) {
      return messages;
    }
    
    // Calcular relevância de cada mensagem para a query atual
    const relevanceScores = await Promise.all(
      messages.map(async (msg) => {
        const score = await this.calculateRelevance(msg.content, currentQuery);
        return { message: msg, score };
      })
    );
    
    // Ordenar por relevância e manter as mais relevantes
    relevanceScores.sort((a, b) => b.score - a.score);
    return relevanceScores
      .slice(0, maxMessages)
      .map(item => item.message);
  }
  
  private async calculateRelevance(
    content: string,
    query: string
  ): Promise<number> {
    // Chamar BAML para calcular relevância
    try {
      const result = await b.CalculateRelevance({
        content,
        query
      });
      return parseFloat(result.score) || 0;
    } catch (error) {
      // Fallback: cálculo simples de similaridade
      return this.simpleSimilarity(content, query);
    }
  }
  
  private simpleSimilarity(str1: string, str2: string): number {
    // Implementação simples de similaridade (ex: Jaccard, cosine, etc.)
    const words1 = new Set(str1.toLowerCase().split(/\W+/));
    const words2 = new Set(str2.toLowerCase().split(/\W+/));
    
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }
}
```

## Persistência Temporária de Informações

### 1. Sistema de Variáveis de Contexto

```typescript
class ContextVariables {
  private variables: Map<string, any> = new Map();
  
  set(key: string, value: any): void {
    this.variables.set(key, value);
  }
  
  get(key: string): any {
    return this.variables.get(key);
  }
  
  has(key: string): boolean {
    return this.variables.has(key);
  }
  
  delete(key: string): boolean {
    return this.variables.delete(key);
  }
  
  getAll(): Record<string, any> {
    const result: Record<string, any> = {};
    for (const [key, value] of this.variables) {
      result[key] = value;
    }
    return result;
  }
  
  clear(): void {
    this.variables.clear();
  }
}
```

### 2. Sistema de Entidades do Contexto

```typescript
class ContextEntities {
  private entities: Map<string, ContextEntity> = new Map();
  
  addEntity(entity: ContextEntity): void {
    this.entities.set(entity.id, entity);
  }
  
  getEntity(id: string): ContextEntity | undefined {
    return this.entities.get(id);
  }
  
  getEntitiesByType(type: string): ContextEntity[] {
    return Array.from(this.entities.values()).filter(e => e.type === type);
  }
  
  updateEntity(id: string, updates: Partial<ContextEntity>): void {
    const entity = this.entities.get(id);
    if (entity) {
      Object.assign(entity, updates);
    }
  }
  
  removeEntity(id: string): boolean {
    return this.entities.delete(id);
  }
}

interface ContextEntity {
  id: string;
  type: string;
  name: string;
  attributes: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
  relevanceScore: number;
}
```

## Integração com o Agente

### Classe de Gerenciamento de Memória

```typescript
class MemoryManager {
  private contextMemory: ContextMemoryStrategy;
  private contextVariables: ContextVariables;
  private contextEntities: ContextEntities;
  private pruningStrategy: PruningStrategy;
  
  constructor(
    contextMemory: ContextMemoryStrategy = new DynamicWindowMemory(),
    pruningStrategy: PruningStrategy = new AgeBasedPruning()
  ) {
    this.contextMemory = contextMemory;
    this.contextVariables = new ContextVariables();
    this.contextEntities = new ContextEntities();
    this.pruningStrategy = pruningStrategy;
  }
  
  // Gerenciamento de mensagens
  addMessage(message: Message): void {
    this.contextMemory.addMessage(message);
  }
  
  getMessages(): Message[] {
    return this.contextMemory.getContext();
  }
  
  // Gerenciamento de variáveis
  setVariable(key: string, value: any): void {
    this.contextVariables.set(key, value);
  }
  
  getVariable(key: string): any {
    return this.contextVariables.get(key);
  }
  
  // Gerenciamento de entidades
  addEntity(entity: ContextEntity): void {
    this.contextEntities.addEntity(entity);
  }
  
  getEntity(id: string): ContextEntity | undefined {
    return this.contextEntities.getEntity(id);
  }
  
  // Pruning inteligente
  async pruneContext(currentQuery?: string): Promise<void> {
    const messages = this.contextMemory.getContext();
    
    if (currentQuery) {
      // Usar estratégia de relevância
      const prunedMessages = await this.pruningStrategy.pruneByRelevance(
        messages,
        currentQuery,
        10 // max messages
      );
      this.contextMemory.replaceMessages(prunedMessages);
    } else {
      // Usar estratégia de idade
      const prunedMessages = this.pruningStrategy.pruneByAge(messages, 60); // 60 minutos
      this.contextMemory.replaceMessages(prunedMessages);
    }
  }
  
  // Limpeza
  clear(): void {
    this.contextMemory.clear();
    this.contextVariables.clear();
    this.contextEntities.clear();
  }
  
  // Serialização para persistência
  serialize(): string {
    return JSON.stringify({
      messages: this.contextMemory.getContext(),
      variables: this.contextVariables.getAll(),
      entities: Array.from(this.contextEntities.entities.values())
    });
  }
  
  // Desserialização
  deserialize(data: string): void {
    const parsed = JSON.parse(data);
    this.contextMemory.replaceMessages(parsed.messages || []);
    Object.entries(parsed.variables || {}).forEach(([key, value]) => {
      this.contextVariables.set(key, value);
    });
    (parsed.entities || []).forEach((entity: ContextEntity) => {
      this.contextEntities.addEntity(entity);
    });
  }
}
```

## Estratégias de Otimização

### 1. Compressão de Contexto

```typescript
class ContextCompressor {
  async compressMessages(messages: Message[]): Promise<CompressedContext> {
    // Identificar mensagens redundantes
    const uniqueMessages = this.removeRedundantMessages(messages);
    
    // Sumarizar conteúdo longo
    const compressedMessages = await Promise.all(
      uniqueMessages.map(async (msg) => {
        if (msg.content.length > 500) { // Limite arbitrário
          const summary = await this.summarizeContent(msg.content);
          return { ...msg, content: summary };
        }
        return msg;
      })
    );
    
    return {
      messages: compressedMessages,
      compressionRatio: this.calculateCompressionRatio(messages, compressedMessages)
    };
  }
  
  private removeRedundantMessages(messages: Message[]): Message[] {
    // Implementar lógica para remover mensagens duplicadas ou muito similares
    const uniqueMessages: Message[] = [];
    const seenContents = new Set<string>();
    
    for (const message of messages) {
      const contentHash = this.hashContent(message.content);
      if (!seenContents.has(contentHash)) {
        uniqueMessages.push(message);
        seenContents.add(contentHash);
      }
    }
    
    return uniqueMessages;
  }
  
  private async summarizeContent(content: string): Promise<string> {
    try {
      return await b.SummarizeText({ text: content, maxLength: 200 });
    } catch (error) {
      // Fallback: truncar conteúdo
      return content.substring(0, 200) + '...';
    }
  }
  
  private calculateCompressionRatio(
    original: Message[],
    compressed: Message[]
  ): number {
    const originalSize = original.reduce((sum, msg) => sum + msg.content.length, 0);
    const compressedSize = compressed.reduce((sum, msg) => sum + msg.content.length, 0);
    return originalSize > 0 ? compressedSize / originalSize : 1;
  }
}
```

## Considerações de Performance

### 1. Limites de Tamanho

```typescript
interface MemoryLimits {
  maxMessages: number;        // Limite de mensagens no histórico
  maxTokens: number;          // Limite de tokens totais
  maxVariables: number;       // Limite de variáveis de contexto
  maxEntities: number;        // Limite de entidades
  maxEntitySize: number;      // Limite de tamanho por entidade (bytes)
  pruneInterval: number;      // Intervalo de pruning (ms)
}
```

### 2. Monitoramento

```typescript
class MemoryMonitor {
  private metrics: MemoryMetrics = {
    messageCount: 0,
    tokenCount: 0,
    variableCount: 0,
    entityCount: 0,
    lastPruneTime: Date.now()
  };
  
  updateMetrics(memoryManager: MemoryManager): void {
    this.metrics.messageCount = memoryManager.getMessages().length;
    this.metrics.tokenCount = this.calculateTokenCount(memoryManager.getMessages());
    this.metrics.variableCount = Object.keys(memoryManager.getVariables()).length;
    this.metrics.entityCount = memoryManager.getEntities().length;
  }
  
  private calculateTokenCount(messages: Message[]): number {
    // Implementar contagem real de tokens
    return messages.reduce((total, msg) => total + msg.content.length / 4, 0);
  }
  
  getMetrics(): MemoryMetrics {
    return { ...this.metrics };
  }
  
  needsPruning(limits: MemoryLimits): boolean {
    return (
      this.metrics.messageCount > limits.maxMessages ||
      this.metrics.tokenCount > limits.maxTokens ||
      this.metrics.variableCount > limits.maxVariables ||
      this.metrics.entityCount > limits.maxEntities ||
      (Date.now() - this.metrics.lastPruneTime) > limits.pruneInterval
    );
  }
}
```

## Próximos Passos

1. Implementar sistema básico de gerenciamento de memória
2. Criar estratégias de pruning por idade e relevância
3. Desenvolver sistema de variáveis de contexto
4. Implementar compressão de contexto
5. Criar monitoramento de uso de memória
6. Integrar com o agente principal
7. Testar com conversas longas e complexas
8. Documentar padrões de uso e boas práticas