============================================
 PLANO: Construtor de Agentes Simples (TS + BAML)
============================================

🎯 OBJETIVO:
Criar um construtor de agentes em TypeScript que utilize a biblioteca BAML para:
- Conexão com LLMs (OpenAI, etc.)
- Montagem de prompts
- Validação/formatagem de saídas
Nosso código cuidará do resto: estado, ciclo de execução, tools, orquestração.

🧭 ETAPAS DE PLANEJAMENTO:

1. ESCOPO DO AGENTE

✅ MVP (Mínimo Viável):
   - System prompt inicial
   - Input do usuário → chamada BAML → resposta
   - Histórico de mensagens (contexto linear)

✅ PRÓXIMO NÍVEL:
   - Suporte a tools/funções
   - Memória de contexto (curto prazo)
   - Configuração dinâmica (modelo, temperatura, etc.)
   - Validação de saída via schema (BAML)
   - Modo streaming (se suportado)

✅ FUTURO (opcional):
   - Agentes multi-passos (plan+execute)
   - Persistência de estado
   - Integração com vector stores
   - Config via JSON/YAML

2. ARQUITETURA DO CONSTRUTOR

🔹 Componentes principais:
   - Configuração do agente (instruções, modelo, tools, schema)
   - Gerenciamento de estado (histórico, variáveis de contexto)
   - Ciclo de execução (input → BAML → resposta/tool → loop → output)
   - Integração com tools (execução + reinserção no contexto)
   - Tratamento de erros e validação

3. INTERFACE DE USO (API)

Exemplo desejado:
   const agente = construtor({
     nome: "Financeiro",
     instrucoes: "...",
     modelo: "gpt-4",
     tools: [tool1, tool2],
     schemaSaida: z.object(...)
   });

   const resposta = await agente.perguntar("...");

Métodos públicos esperados:
   - .perguntar(input: string) → Promise<string|object>
   - .resetar() → void
   - .obterContexto() → histórico

Stateful: mantém memória entre chamadas.

4. INTEGRAÇÃO COM BAML

Mapear:
   - Assinatura da chamada principal da BAML
   - Estrutura de retorno (texto? tool_calls? tokens?)
   - Suporte a function calling
   - Suporte a schemas de saída (Zod? JSON Schema?)
   - Suporte a streaming

Isso definirá:
   - Como montar o payload de chamada
   - Como tratar tool_calls no ciclo
   - Como validar/parsear a resposta final

5. FLUXO DE EXECUÇÃO (com tools)

1. Usuário envia pergunta
2. Adiciona ao histórico como mensagem "user"
3. Chama BAML com histórico + tools
4. Se BAML retorna tool_calls:
   → Executa cada tool
   → Adiciona resultado como mensagem "tool"
   → Volta ao passo 3
5. Se BAML retorna resposta final:
   → Adiciona como "assistant"
   → Retorna ao usuário

6. EXTENSIBILIDADE

Facilitar:
   - Adição de novas tools (interface padrão: {name, description, execute})
   - Criação de "templates" de agentes (ex: Agente de Suporte, Analista de Dados)
   - Troca de provedor/modelo via config
   - Schemas de saída customizáveis

7. TESTES E VALIDAÇÃO

✅ Unitários:
   - Criação do agente (config válida/inválida)
   - Chamada sem tools
   - Chamada com tool mockada
   - Validação de schema

✅ Integração:
   - Chamada real à BAML (sandbox)
   - Fluxo completo com 1+ tools

✅ Borda:
   - Resposta muito longa
   - Tool falha
   - Parsing inválido
   - Modelo indisponível

8. DOCUMENTAÇÃO

Incluir:
   - Como instanciar um agente
   - Como criar/adicionar tools
   - Como definir schemas de saída
   - Exemplos de uso comuns

🗺️ MAPA MENTAL RESUMIDO:

Construtor de Agentes (TypeScript)
│
├── Entrada: Configuração (instruções, modelo, tools, schema)
├── Saída: Instância de Agente
│
├── Agente:
│   ├── Estado: Histórico + variáveis
│   ├── Método: .perguntar(input) → resposta
│   ├── Método: .resetar()
│   └── Método: .obterContexto()
│
├── Ciclo:
│   input → contexto → BAML → resposta/tool → executa tool → BAML → ... → resposta final
│
├── Integração com BAML:
│   - Chamada com mensagens, tools, schema
│   - Tratamento de tool_calls
│   - Validação de saídas
│
├── Extensível:
│   - Novas tools
│   - Novos agentes
│   - Novos schemas
│
└── Testes:
    - Unitários
    - Integração
    - Borda

✅ PRÓXIMOS PASSOS:

1. Revisar documentação da BAML → entender limites e capacidades
2. Definir MVP exato → qual primeiro agente funcional?
3. Desenhar fluxo de execução → diagrama ou texto sequencial
4. Listar 2-3 tools iniciais → foco em utilidade imediata
5. Definir 1-2 schemas de saída → estruturados para validação