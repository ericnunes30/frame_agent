# Arquitetura para Agentes Multi-Passos e Funcionalidades Avançadas

## Evolução da Arquitetura Atual

A arquitetura atual precisa ser expandida para suportar agentes multi-passos, persistência de estado, integração com vector stores e configuração flexível:

```
Construtor de Agentes (TypeScript) - Fase 3
│
├── Entrada: Configuração (instruções, modelo, tools, schema, persistência, vector stores)
├── Saída: Instância de Agente (Simples ou Multi-Passos)
│
├── Agente Simples (herdado da Fase 2):
│   ├── Estado: Histórico + variáveis + contexto
│   ├── Configuração: Modelo, temperatura, parâmetros
│   ├── Tools: Registro e gerenciamento de ferramentas
│   ├── Método: .sendMessage(message) → resposta
│   ├── Método: .sendStructuredMessage(message) → resposta estruturada
│   ├── Método: .executeTool(toolName, args) → resultado
│   ├── Método: .reset()
│   └── Método: .getHistory()
│
├── Agente Multi-Passos (nova):
│   ├── Estado: Histórico + variáveis + contexto + plano + estado de execução
│   ├── Configuração: Modelo, temperatura, parâmetros, persistência, vector stores
│   ├── Tools: Registro e gerenciamento de ferramentas
│   ├── Planner: Planejador de tarefas complexas
│   ├── Executor: Executor de planos
│   ├── VectorStore: Integração com vector stores
│   ├── Persistence: Gerenciamento de persistência de estado
│   ├── Método: .sendMessage(message) → resposta
│   ├── Método: .sendStructuredMessage(message) → resposta estruturada
│   ├── Método: .executeTool(toolName, args) → resultado
│   ├── Método: .executePlan(plan) → resultado
│   ├── Método: .reset()
│   └── Método: .getHistory()
│
├── Ciclo (com tools e plan+execute):
│   input → contexto → BAML → resposta/tool/plan → 
│   se tool_calls:
│     → Executar tools → Adicionar resultados ao contexto → BAML
│   se plan:
│     → Decompor em sub-tarefas → Executar sub-tarefas → Agregar resultados → BAML
│   se resposta final:
│     → Adicionar ao histórico → Persistir estado → Retornar ao usuário
│
├── Integração com BAML:
│   - Chamada com mensagens, tools registradas, schema
│   - Tratamento de tool_calls, planos e execução
│   - Validação de saídas com schemas
│   - Suporte a streaming (se disponível)
│
├── Sistema de Tools:
│   - Registro de tools com interface padrão
│   - Execução assíncrona de tools
│   - Tratamento de erros em tools
│   - Timeout e limites de execução
│
├── Planner e Executor:
│   - Planejamento de tarefas complexas
│   - Decomposição em sub-tarefas
│   - Gerenciamento de dependências
│   - Tratamento de falhas e retries
│
├── Vector Store Integration:
│   - Conectores para vector stores populares
│   - Indexação de documentos
│   - Recuperação de informações (RAG)
│   - Atualização de índices
│
├── Persistência de Estado:
│   - Serialização completa do contexto
│   - Armazenamento em diferentes backends
│   - Versionamento de estado
│   - Restauração de sessões
│
├── Configuração Flexível:
│   - Definição via JSON/YAML
│   - Templates reutilizáveis
│   - Validação de configurações
│   - Suporte a variáveis de ambiente
│
└── Testes:
    - Unitários para cada componente
    - Integração com tools reais
    - Testes de agentes multi-passos
    - Testes de persistência
    - Testes com vector stores
    - Testes de borda e erro
```

## Componentes Principais da Nova Arquitetura

### 1. Agente Multi-Passos

```typescript
interface MultiStepAgentConfig extends AgentConfig {
  persistence?: PersistenceConfig;
  vectorStores?: VectorStoreConfig[];
  planExecution?: PlanExecutionConfig;
}

class MultiStepAgent extends ChatAgent {
  private planner: TaskPlanner;
  private executor: PlanExecutor;
  private vectorStores: VectorStoreManager;
  private persistence: PersistenceManager;
  
  // Métodos herdados da Fase 2
  async sendMessage(message: string): Promise<string>;
  async sendStructuredMessage(message: string): Promise<StructuredResponse>;
  async executeTool(toolName: string, args: any): Promise<any>;
  
  // Novos métodos
  async executePlan(plan: ExecutionPlan): Promise<PlanResult>;
  async planTask(task: string): Promise<ExecutionPlan>;
  saveState(): Promise<void>;
  loadState(stateId: string): Promise<void>;
  searchKnowledge(query: string): Promise<SearchResult[]>;
}
```

### 2. Planner e Executor

```typescript
interface ExecutionPlan {
  taskId: string;
  steps: ExecutionStep[];
  dependencies: Record<string, string[]>;
  context: Record<string, any>;
}

interface ExecutionStep {
  id: string;
  description: string;
  toolName?: string;
  toolArgs?: any;
  subPlan?: ExecutionPlan;
  expectedOutput: string;
}

interface TaskPlanner {
  plan(task: string, context: any): Promise<ExecutionPlan>;
  decompose(task: string, context: any): Promise<ExecutionStep[]>;
  validate(plan: ExecutionPlan): boolean;
}

interface PlanExecutor {
  execute(plan: ExecutionPlan): Promise<PlanResult>;
  executeStep(step: ExecutionStep): Promise<any>;
  handleFailure(step: ExecutionStep, error: Error): Promise<RecoveryAction>;
}
```

### 3. Vector Store Manager

```typescript
interface VectorStoreConfig {
  type: 'pinecone' | 'weaviate' | 'chroma' | 'qdrant';
  apiKey: string;
  indexName: string;
  dimension: number;
}

interface VectorStoreManager {
  connect(config: VectorStoreConfig): Promise<void>;
  index(documents: Document[]): Promise<void>;
  search(query: string, topK?: number): Promise<SearchResult[]>;
  update(document: Document): Promise<void>;
  delete(documentId: string): Promise<void>;
}

interface Document {
  id: string;
  content: string;
  metadata: Record<string, any>;
  embedding?: number[];
}

interface SearchResult {
  document: Document;
  score: number;
}
```

### 4. Persistence Manager

```typescript
interface PersistenceConfig {
  backend: 'file' | 'sqlite' | 'postgresql' | 'mongodb';
  connectionString?: string;
  filePath?: string;
  autoSave?: boolean;
  saveInterval?: number; // em milissegundos
}

interface PersistenceManager {
  save(state: AgentState, stateId?: string): Promise<string>;
  load(stateId: string): Promise<AgentState>;
  listStates(): Promise<StateMetadata[]>;
  deleteState(stateId: string): Promise<boolean>;
  autoSave(agent: ChatAgent): void;
}

interface AgentState {
  history: ChatMessage[];
  contextVariables: Record<string, any>;
  tools: Tool[];
  config: AgentConfig;
  metadata: StateMetadata;
}

interface StateMetadata {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  version: string;
  tags: string[];
}
```

### 5. Config Manager

```typescript
interface ConfigManager {
  loadFromFile(path: string): Promise<AgentConfig>;
  loadFromYAML(yamlString: string): Promise<AgentConfig>;
  loadFromJSON(jsonString: string): Promise<AgentConfig>;
  validate(config: any): Promise<ValidationResult>;
  applyDefaults(config: Partial<AgentConfig>): AgentConfig;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}
```

## Fluxo de Execução Expandido

### 1. Inicialização
- Criar agente com configuração avançada
- Conectar vector stores
- Configurar persistência
- Registrar tools necessárias

### 2. Envio de Mensagem Simples
- Adicionar mensagem ao histórico
- Preparar contexto com histórico + tools
- Chamar função BAML com tools registradas
- Processar resposta/tool/plan

### 3. Processamento de Resposta
- Se tool_calls:
  → Executar cada tool em paralelo
  → Adicionar resultados ao contexto
  → Chamar BAML novamente
- Se plan:
  → Decompor em sub-tarefas
  → Executar sub-tarefas
  → Agregar resultados
  → Chamar BAML novamente
- Se resposta final:
  → Adicionar ao histórico
  → Persistir estado
  → Retornar ao usuário

### 4. Gerenciamento de Estado
- Manter janela de contexto otimizada
- Persistir estado periodicamente ou sob demanda
- Restaurar estado de sessões anteriores
- Versionar estados importantes

### 5. Integração com Vector Stores
- Indexar documentos relevantes
- Buscar informações para enriquecer contexto
- Atualizar índices conforme necessário
- Gerenciar embeddings

## Considerações de Design

### 1. Extensibilidade
- Interface padronizada para vector stores
- Plugin system para backends de persistência
- Suporte a tools síncronas e assíncronas
- Hooks para customização de comportamento

### 2. Segurança
- Validação de parâmetros de tools
- Timeout para execução de tools
- Limites de recursão para evitar loops infinitos
- Sanitização de dados de entrada/saída

### 3. Performance
- Execução paralela de tools independentes
- Caching de resultados de tools e buscas
- Pruning inteligente do histórico de mensagens
- Lazy loading de componentes opcionais

### 4. Tratamento de Erros
- Mecanismos de retry para tools falhas
- Fallback quando vector stores não estão disponíveis
- Logging detalhado para debugging
- Recuperação de estado após falhas

## Próximos Passos

1. Implementar interface de Agente Multi-Passos
2. Criar sistema de Planner e Executor
3. Desenvolver conectores para vector stores
4. Implementar gerenciador de persistência
5. Adicionar suporte a configuração via JSON/YAML
6. Testar integração completa
7. Documentar cada componente em detalhes