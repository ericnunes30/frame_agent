# Persistência de Estado

## Visão Geral

A persistência de estado permite que os agentes mantenham e restaurem seu contexto, histórico e configurações entre diferentes sessões de execução. Isso é essencial para agentes que precisam manter continuidade em conversas longas ou tarefas que se estendem por períodos prolongados.

## Conceito de Persistência

A persistência de estado envolve:
- Serialização completa do estado do agente
- Armazenamento em backends confiáveis
- Restauração de sessões anteriores
- Versionamento e gerenciamento de múltiplos estados

## Interface de Persistência

```typescript
interface PersistenceConfig {
  backend: 'file' | 'sqlite' | 'postgresql' | 'mongodb' | 'redis';
  connectionString?: string;
  filePath?: string;
  autoSave?: boolean;
  saveInterval?: number; // em milissegundos
  compression?: boolean;
  encryption?: boolean;
}

interface PersistenceManager {
  save(state: AgentState, stateId?: string): Promise<string>;
  load(stateId: string): Promise<AgentState>;
  listStates(filter?: StateFilter): Promise<StateMetadata[]>;
  deleteState(stateId: string): Promise<boolean>;
  updateState(stateId: string, updates: Partial<AgentState>): Promise<void>;
  autoSave(agent: ChatAgent): void;
  stopAutoSave(): void;
}

interface AgentState {
  id: string;
  version: string;
  createdAt: Date;
  updatedAt: Date;
  history: ChatMessage[];
  contextVariables: Record<string, any>;
  tools: SerializedTool[];
  config: AgentConfig;
  metadata: Record<string, any>;
  tags: string[];
}

interface StateMetadata {
  id: string;
  version: string;
  createdAt: Date;
  updatedAt: Date;
  size: number;
  tags: string[];
  preview: string; // Primeiras N mensagens do histórico
}

interface StateFilter {
  tags?: string[];
  dateRange?: { from: Date; to: Date };
  version?: string;
}
```

## Implementações de Backends

### 1. File System Backend

```typescript
class FileSystemPersistence implements PersistenceManager {
  private basePath: string;
  private autoSaveTimer: NodeJS.Timeout | null = null;
  
  constructor(config: { basePath: string }) {
    this.basePath = config.basePath;
    // Criar diretório se não existir
    if (!fs.existsSync(this.basePath)) {
      fs.mkdirSync(this.basePath, { recursive: true });
    }
  }
  
  async save(state: AgentState, stateId?: string): Promise<string> {
    const id = stateId || state.id || this.generateId();
    const filePath = path.join(this.basePath, `${id}.json`);
    
    // Serializar estado
    const serializedState = this.serializeState(state);
    
    // Salvar arquivo
    await fs.promises.writeFile(filePath, serializedState);
    
    return id;
  }
  
  async load(stateId: string): Promise<AgentState> {
    const filePath = path.join(this.basePath, `${stateId}.json`);
    
    if (!fs.existsSync(filePath)) {
      throw new Error(`Estado com ID ${stateId} não encontrado`);
    }
    
    const data = await fs.promises.readFile(filePath, 'utf8');
    return this.deserializeState(data);
  }
  
  async listStates(filter?: StateFilter): Promise<StateMetadata[]> {
    const files = await fs.promises.readdir(this.basePath);
    const states: StateMetadata[] = [];
    
    for (const file of files) {
      if (file.endsWith('.json')) {
        const stateId = file.replace('.json', '');
        try {
          const state = await this.load(stateId);
          const metadata: StateMetadata = {
            id: state.id,
            version: state.version,
            createdAt: state.createdAt,
            updatedAt: state.updatedAt,
            size: (await fs.promises.stat(path.join(this.basePath, file))).size,
            tags: state.tags,
            preview: this.getHistoryPreview(state.history)
          };
          
          if (this.matchesFilter(metadata, filter)) {
            states.push(metadata);
          }
        } catch (error) {
          console.warn(`Não foi possível carregar estado ${stateId}:`, error);
        }
      }
    }
    
    return states.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());
  }
  
  async deleteState(stateId: string): Promise<boolean> {
    const filePath = path.join(this.basePath, `${stateId}.json`);
    
    if (fs.existsSync(filePath)) {
      await fs.promises.unlink(filePath);
      return true;
    }
    
    return false;
  }
  
  autoSave(agent: ChatAgent): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
    }
    
    const config = agent.getPersistenceConfig();
    this.autoSaveTimer = setInterval(async () => {
      try {
        const state = agent.getCurrentState();
        await this.save(state);
      } catch (error) {
        console.error('Erro no auto-save:', error);
      }
    }, config.saveInterval || 30000); // Default: 30 segundos
  }
  
  stopAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }
  
  private serializeState(state: AgentState): string {
    const data = {
      ...state,
      createdAt: state.createdAt.toISOString(),
      updatedAt: state.updatedAt.toISOString()
    };
    
    let jsonString = JSON.stringify(data, null, 2);
    
    // Comprimir se configurado
    if (this.config.compression) {
      jsonString = this.compress(jsonString);
    }
    
    return jsonString;
  }
  
  private deserializeState(data: string): AgentState {
    let jsonString = data;
    
    // Descomprimir se necessário
    if (this.config.compression) {
      jsonString = this.decompress(jsonString);
    }
    
    const parsed = JSON.parse(jsonString);
    
    return {
      ...parsed,
      createdAt: new Date(parsed.createdAt),
      updatedAt: new Date(parsed.updatedAt)
    };
  }
  
  private generateId(): string {
    return `state_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private getHistoryPreview(history: ChatMessage[]): string {
    return history.slice(0, 3).map(msg => `${msg.role}: ${msg.content.substring(0, 50)}...`).join('\n');
  }
  
  private matchesFilter(metadata: StateMetadata, filter?: StateFilter): boolean {
    if (!filter) return true;
    
    if (filter.tags && filter.tags.length > 0) {
      if (!metadata.tags.some(tag => filter.tags!.includes(tag))) {
        return false;
      }
    }
    
    if (filter.dateRange) {
      const updatedAt = metadata.updatedAt.getTime();
      if (filter.dateRange.from && updatedAt < filter.dateRange.from.getTime()) {
        return false;
      }
      if (filter.dateRange.to && updatedAt > filter.dateRange.to.getTime()) {
        return false;
      }
    }
    
    if (filter.version && metadata.version !== filter.version) {
      return false;
    }
    
    return true;
  }
}
```

### 2. Banco de Dados Backend (SQLite)

```typescript
class SQLitePersistence implements PersistenceManager {
  private db: sqlite3.Database;
  private autoSaveTimer: NodeJS.Timeout | null = null;
  
  constructor(config: { filePath: string }) {
    this.db = new sqlite3.Database(config.filePath);
    this.initializeDatabase();
  }
  
  private initializeDatabase(): void {
    this.db.run(`
      CREATE TABLE IF NOT EXISTS agent_states (
        id TEXT PRIMARY KEY,
        version TEXT,
        created_at TEXT,
        updated_at TEXT,
        data TEXT,
        tags TEXT,
        size INTEGER
      )
    `);
  }
  
  async save(state: AgentState, stateId?: string): Promise<string> {
    const id = stateId || state.id || this.generateId();
    const serializedData = this.serializeState(state);
    
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT OR REPLACE INTO agent_states 
         (id, version, created_at, updated_at, data, tags, size) 
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          state.version,
          state.createdAt.toISOString(),
          new Date().toISOString(),
          serializedData,
          JSON.stringify(state.tags),
          serializedData.length
        ],
        (error) => {
          if (error) {
            reject(error);
          } else {
            resolve(id);
          }
        }
      );
    });
  }
  
  async load(stateId: string): Promise<AgentState> {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM agent_states WHERE id = ?',
        [stateId],
        (error, row: any) => {
          if (error) {
            reject(error);
          } else if (!row) {
            reject(new Error(`Estado com ID ${stateId} não encontrado`));
          } else {
            resolve(this.deserializeState(row.data));
          }
        }
      );
    });
  }
  
  async listStates(filter?: StateFilter): Promise<StateMetadata[]> {
    let query = 'SELECT id, version, created_at, updated_at, tags, size FROM agent_states';
    const params: any[] = [];
    
    if (filter) {
      const conditions: string[] = [];
      
      if (filter.version) {
        conditions.push('version = ?');
        params.push(filter.version);
      }
      
      if (filter.dateRange) {
        if (filter.dateRange.from) {
          conditions.push('updated_at >= ?');
          params.push(filter.dateRange.from.toISOString());
        }
        if (filter.dateRange.to) {
          conditions.push('updated_at <= ?');
          params.push(filter.dateRange.to.toISOString());
        }
      }
      
      if (conditions.length > 0) {
        query += ' WHERE ' + conditions.join(' AND ');
      }
    }
    
    query += ' ORDER BY updated_at DESC';
    
    return new Promise((resolve, reject) => {
      this.db.all(query, params, (error, rows: any[]) => {
        if (error) {
          reject(error);
        } else {
          const metadata: StateMetadata[] = rows.map(row => ({
            id: row.id,
            version: row.version,
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at),
            size: row.size,
            tags: JSON.parse(row.tags),
            preview: '' // Preview seria carregado separadamente para performance
          }));
          resolve(metadata);
        }
      });
    });
  }
  
  async deleteState(stateId: string): Promise<boolean> {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM agent_states WHERE id = ?',
        [stateId],
        function(error) {
          if (error) {
            reject(error);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }
  
  // Outros métodos similares ao File System Backend
}
```

## Integração com o Agente

### Extensão da Classe ChatAgent

```typescript
class PersistentAgent extends ChatAgent {
  private persistenceManager: PersistenceManager | null = null;
  private currentStateId: string | null = null;
  
  setPersistence(config: PersistenceConfig): void {
    switch (config.backend) {
      case 'file':
        this.persistenceManager = new FileSystemPersistence({ basePath: config.filePath || './states' });
        break;
      case 'sqlite':
        this.persistenceManager = new SQLitePersistence({ filePath: config.connectionString || './agent.db' });
        break;
      // Adicionar outros backends
      default:
        throw new Error(`Backend de persistência não suportado: ${config.backend}`);
    }
  }
  
  async saveState(stateId?: string): Promise<string> {
    if (!this.persistenceManager) {
      throw new Error('Persistência não configurada');
    }
    
    const state: AgentState = {
      id: stateId || this.generateStateId(),
      version: '1.0.0',
      createdAt: new Date(),
      updatedAt: new Date(),
      history: this.getHistory(),
      contextVariables: this.getAllContextVariables(),
      tools: this.serializeTools(),
      config: this.getConfig(),
      metadata: {},
      tags: []
    };
    
    const savedId = await this.persistenceManager.save(state, stateId);
    this.currentStateId = savedId;
    
    return savedId;
  }
  
  async loadState(stateId: string): Promise<void> {
    if (!this.persistenceManager) {
      throw new Error('Persistência não configurada');
    }
    
    const state = await this.persistenceManager.load(stateId);
    
    // Restaurar estado
    this.reset();
    state.history.forEach(msg => this.memoryManager.addMessage(msg));
    
    Object.entries(state.contextVariables).forEach(([key, value]) => {
      this.memoryManager.setVariable(key, value);
    });
    
    this.setConfig(state.config);
    
    // Restaurar tools
    this.deserializeTools(state.tools);
    
    this.currentStateId = stateId;
  }
  
  async listStates(filter?: StateFilter): Promise<StateMetadata[]> {
    if (!this.persistenceManager) {
      throw new Error('Persistência não configurada');
    }
    
    return await this.persistenceManager.listStates(filter);
  }
  
  enableAutoSave(): void {
    if (this.persistenceManager) {
      this.persistenceManager.autoSave(this);
    }
  }
  
  disableAutoSave(): void {
    if (this.persistenceManager) {
      this.persistenceManager.stopAutoSave();
    }
  }
  
  private generateStateId(): string {
    return `agent_${this.config.name}_${Date.now()}`;
  }
  
  getCurrentState(): AgentState {
    return {
      id: this.currentStateId || this.generateStateId(),
      version: '1.0.0',
      createdAt: new Date(),
      updatedAt: new Date(),
      history: this.getHistory(),
      contextVariables: this.getAllContextVariables(),
      tools: this.serializeTools(),
      config: this.getConfig(),
      metadata: {},
      tags: []
    };
  }
}
```

## Exemplos de Uso

### 1. Persistência Básica

```typescript
const agent = new PersistentAgent({
  name: "Assistente",
  instructions: "Você é um assistente útil",
  provider: "openai-generic"
});

// Configurar persistência
agent.setPersistence({
  backend: 'file',
  filePath: './agent-states',
  autoSave: true,
  saveInterval: 60000 // 1 minuto
});

// Conversa longa
await agent.sendMessage("Olá, qual é o seu nome?");
await agent.sendMessage("Me conte sobre inteligência artificial");
await agent.sendMessage("Quais são as principais aplicações?");
await agent.sendMessage("Como posso começar a estudar IA?");

// Salvar estado manualmente
const stateId = await agent.saveState();
console.log(`Estado salvo com ID: ${stateId}`);

// Em outra sessão...
const agent2 = new PersistentAgent({
  name: "Assistente",
  instructions: "Você é um assistente útil",
  provider: "openai-generic"
});

agent2.setPersistence({
  backend: 'file',
  filePath: './agent-states'
});

// Carregar estado anterior
await agent2.loadState(stateId);
console.log("Histórico restaurado:", agent2.getHistory());
```

### 2. Gerenciamento de Múltiplos Estados

```typescript
const agent = new PersistentAgent({
  name: "Analista",
  instructions: "Você é um analista de dados",
  provider: "openai-generic"
});

agent.setPersistence({
  backend: 'sqlite',
  connectionString: './analyst.db'
});

// Trabalhar em diferentes projetos
await agent.sendMessage("Vamos analisar dados de vendas de 2023");
// ... várias interações ...
await agent.saveState("projeto_vendas_2023");

agent.reset();
await agent.sendMessage("Agora vamos analisar dados de marketing");
// ... várias interações ...
await agent.saveState("projeto_marketing_2023");

// Listar estados salvos
const states = await agent.listStates();
console.log("Estados disponíveis:", states);

// Carregar projeto específico
await agent.loadState("projeto_vendas_2023");
```

## Considerações de Implementação

### 1. Segurança
- Criptografia de dados sensíveis
- Controle de acesso a estados
- Validação de integridade dos dados

### 2. Performance
- Compressão de estados grandes
- Indexação para buscas rápidas
- Caching de estados frequentemente acessados

### 3. Confiabilidade
- Transações atômicas em operações de salvamento
- Backup automático de estados importantes
- Tratamento de falhas de persistência

### 4. Escalabilidade
- Sharding de estados em sistemas distribuídos
- Limites de tamanho para estados
- Políticas de retenção automática

## Próximos Passos

1. Implementar protótipo do FileSystemPersistence
2. Criar SQLitePersistence
3. Desenvolver mecanismo de auto-save
4. Adicionar suporte a compressão e criptografia
5. Testar cenários de restauração de estado
6. Implementar outros backends (PostgreSQL, MongoDB)
7. Documentar padrões de uso e boas práticas