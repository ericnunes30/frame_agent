# Configuração via JSON/YAML

## Visão Geral

A configuração via JSON/YAML permite definir agentes de forma declarativa, facilitando a reutilização, versionamento e gerenciamento de diferentes tipos de agentes. Esta abordagem proporciona flexibilidade na criação de agentes especializados e templates reutilizáveis.

## Conceito de Configuração Declarativa

A configuração declarativa permite:
- Definir agentes através de arquivos de configuração
- Versionar configurações no controle de versão
- Reutilizar templates de agentes
- Parametrizar configurações com variáveis de ambiente

## Estrutura de Configuração

### Schema de Configuração Básica

```yaml
# agent-config.yaml
name: string
description: string
version: string
instructions: string
provider: string
model: string
temperature: number
topP: number
maxTokens: number
tools: ToolConfig[]
schemas: SchemaConfig[]
persistence: PersistenceConfig
vectorStores: VectorStoreConfig[]
tags: string[]
metadata: Record<string, any>
```

### ToolConfig

```yaml
tools:
  - name: string
    type: 'builtin' | 'custom' | 'external'
    path: string  # Para custom tools
    url: string   # Para external tools
    parameters: Record<string, any>
    enabled: boolean
```

### SchemaConfig

```yaml
schemas:
  - name: string
    type: 'baml' | 'zod' | 'json'
    path: string
    validation: boolean
```

### PersistenceConfig

```yaml
persistence:
  backend: 'file' | 'sqlite' | 'postgresql' | 'mongodb'
  path: string
  connectionString: string
  autoSave: boolean
  saveInterval: number
```

### VectorStoreConfig

```yaml
vectorStores:
  - name: string
    type: 'pinecone' | 'weaviate' | 'chroma' | 'qdrant'
    apiKey: string
    url: string
    indexName: string
    dimension: number
```

## Exemplos de Configuração

### 1. Agente Básico

```yaml
# simple-agent.yaml
name: "Assistente Básico"
description: "Um agente simples para conversas gerais"
version: "1.0.0"
instructions: "Você é um assistente útil e educado"
provider: "openai-generic"
model: "gpt-4o-mini"
temperature: 0.7
maxTokens: 1000

tags:
  - "general"
  - "conversation"

metadata:
  created_by: "admin"
  department: "support"
```

### 2. Agente com Tools

```yaml
# tools-agent.yaml
name: "Agente com Tools"
description: "Agente especializado com acesso a ferramentas"
version: "1.0.0"
instructions: |
  Você é um assistente especializado que pode usar ferramentas para ajudar os usuários.
  Use as ferramentas quando apropriado para fornecer respostas precisas.
provider: "openai-generic"
model: "gpt-4o-mini"
temperature: 0.5

tools:
  - name: "calculator"
    type: "builtin"
    enabled: true
  
  - name: "datetime"
    type: "builtin"
    enabled: true
  
  - name: "web_search"
    type: "custom"
    path: "./tools/web-search.js"
    enabled: true
    parameters:
      max_results: 5

tags:
  - "tools"
  - "utility"

metadata:
  created_by: "developer"
  department: "engineering"
```

### 3. Agente com Persistência

```yaml
# persistent-agent.yaml
name: "Agente Persistente"
description: "Agente que mantém estado entre sessões"
version: "1.0.0"
instructions: |
  Você é um assistente que lembra conversas anteriores e preferências do usuário.
  Use o histórico para personalizar suas respostas.
provider: "openai-generic"
model: "gpt-4o-mini"
temperature: 0.7

persistence:
  backend: "sqlite"
  connectionString: "./states/agent.db"
  autoSave: true
  saveInterval: 60000

tags:
  - "persistence"
  - "memory"

metadata:
  created_by: "admin"
  department: "support"
```

### 4. Agente com Vector Stores (RAG)

```yaml
# rag-agent.yaml
name: "Agente RAG"
description: "Agente com acesso a base de conhecimento"
version: "1.0.0"
instructions: |
  Você é um assistente especializado com acesso a uma base de conhecimento técnica.
  Use as informações da base para fornecer respostas precisas e atualizadas.
provider: "openai-generic"
model: "gpt-4o-mini"
temperature: 0.3

vectorStores:
  - name: "technical_docs"
    type: "pinecone"
    apiKey: "${PINECONE_API_KEY}"
    indexName: "technical-documents"
    dimension: 1536
    namespace: "v1"

schemas:
  - name: "structured_response"
    type: "baml"
    path: "./schemas/response.baml"
    validation: true

tags:
  - "rag"
  - "knowledge-base"
  - "technical"

metadata:
  created_by: "ml-team"
  department: "research"
```

### 5. Agente Multi-Passos

```yaml
# multi-step-agent.yaml
name: "Agente Multi-Passos"
description: "Agente capaz de executar tarefas complexas"
version: "1.0.0"
instructions: |
  Você é um assistente especializado em resolver tarefas complexas.
  Planeje e execute tarefas em múltiplos passos quando necessário.
provider: "openai-generic"
model: "gpt-4o"
temperature: 0.5

tools:
  - name: "web_search"
    type: "custom"
    path: "./tools/web-search.js"
    enabled: true
  
  - name: "document_analyzer"
    type: "custom"
    path: "./tools/document-analyzer.js"
    enabled: true
  
  - name: "report_generator"
    type: "custom"
    path: "./tools/report-generator.js"
    enabled: true

persistence:
  backend: "file"
  path: "./states"
  autoSave: true
  saveInterval: 30000

vectorStores:
  - name: "research_papers"
    type: "chroma"
    url: "http://localhost:8000"
    indexName: "research-papers"
    dimension: 1536

tags:
  - "multi-step"
  - "planning"
  - "complex-tasks"

metadata:
  created_by: "research-team"
  department: "innovation"
```

## Interface de Config Manager

```typescript
interface ConfigManager {
  loadFromFile(path: string): Promise<AgentConfig>;
  loadFromYAML(yamlString: string): Promise<AgentConfig>;
  loadFromJSON(jsonString: string): Promise<AgentConfig>;
  saveToFile(config: AgentConfig, path: string): Promise<void>;
  validate(config: any): Promise<ValidationResult>;
  applyDefaults(config: Partial<AgentConfig>): AgentConfig;
  resolveVariables(config: AgentConfig): AgentConfig;
  merge(baseConfig: AgentConfig, overrideConfig: AgentConfig): AgentConfig;
}

interface AgentConfig {
  name: string;
  description?: string;
  version?: string;
  instructions: string;
  provider: string;
  model?: string;
  temperature?: number;
  topP?: number;
  maxTokens?: number;
  tools?: ToolConfig[];
  schemas?: SchemaConfig[];
  persistence?: PersistenceConfig;
  vectorStores?: VectorStoreConfig[];
  tags?: string[];
  metadata?: Record<string, any>;
}

interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface ValidationError {
  path: string;
  message: string;
  severity: 'error' | 'warning';
}
```

## Implementação do Config Manager

```typescript
class YAMLConfigManager implements ConfigManager {
  private schemaValidator: SchemaValidator;
  
  constructor() {
    this.schemaValidator = new SchemaValidator();
  }
  
  async loadFromFile(path: string): Promise<AgentConfig> {
    const content = await fs.promises.readFile(path, 'utf8');
    const parsed = yaml.parse(content);
    const resolved = this.resolveVariables(parsed);
    const validated = await this.validate(resolved);
    
    if (!validated.isValid) {
      throw new Error(`Configuração inválida: ${validated.errors.map(e => e.message).join(', ')}`);
    }
    
    return this.applyDefaults(resolved);
  }
  
  async loadFromYAML(yamlString: string): Promise<AgentConfig> {
    const parsed = yaml.parse(yamlString);
    const resolved = this.resolveVariables(parsed);
    const validated = await this.validate(resolved);
    
    if (!validated.isValid) {
      throw new Error(`Configuração inválida: ${validated.errors.map(e => e.message).join(', ')}`);
    }
    
    return this.applyDefaults(resolved);
  }
  
  async loadFromJSON(jsonString: string): Promise<AgentConfig> {
    const parsed = JSON.parse(jsonString);
    const resolved = this.resolveVariables(parsed);
    const validated = await this.validate(resolved);
    
    if (!validated.isValid) {
      throw new Error(`Configuração inválida: ${validated.errors.map(e => e.message).join(', ')}`);
    }
    
    return this.applyDefaults(resolved);
  }
  
  async saveToFile(config: AgentConfig, path: string): Promise<void> {
    const validated = await this.validate(config);
    
    if (!validated.isValid) {
      throw new Error(`Configuração inválida: ${validated.errors.map(e => e.message).join(', ')}`);
    }
    
    const yamlString = yaml.stringify(config);
    await fs.promises.writeFile(path, yamlString, 'utf8');
  }
  
  async validate(config: any): Promise<ValidationResult> {
    return await this.schemaValidator.validate(config);
  }
  
  applyDefaults(config: Partial<AgentConfig>): AgentConfig {
    const defaults: Partial<AgentConfig> = {
      provider: 'openai-generic',
      temperature: 0.7,
      maxTokens: 2000,
      topP: 1.0
    };
    
    return {
      ...defaults,
      ...config
    } as AgentConfig;
  }
  
  resolveVariables(config: AgentConfig): AgentConfig {
    const resolved = JSON.parse(JSON.stringify(config));
    
    // Resolver variáveis de ambiente
    const resolveValue = (value: any): any => {
      if (typeof value === 'string' && value.startsWith('${') && value.endsWith('}')) {
        const varName = value.slice(2, -1);
        return process.env[varName] || value;
      }
      
      if (typeof value === 'object' && value !== null) {
        if (Array.isArray(value)) {
          return value.map(resolveValue);
        }
        
        const resolvedObj: Record<string, any> = {};
        for (const [key, val] of Object.entries(value)) {
          resolvedObj[key] = resolveValue(val);
        }
        return resolvedObj;
      }
      
      return value;
    };
    
    return resolveValue(resolved);
  }
  
  merge(baseConfig: AgentConfig, overrideConfig: AgentConfig): AgentConfig {
    return {
      ...baseConfig,
      ...overrideConfig,
      tools: [...(baseConfig.tools || []), ...(overrideConfig.tools || [])],
      schemas: [...(baseConfig.schemas || []), ...(overrideConfig.schemas || [])],
      tags: [...(baseConfig.tags || []), ...(overrideConfig.tags || [])],
      metadata: {
        ...(baseConfig.metadata || {}),
        ...(overrideConfig.metadata || {})
      }
    };
  }
}
```

## Integração com o Agente

### Factory de Agentes

```typescript
class AgentFactory {
  private configManager: ConfigManager;
  
  constructor(configManager: ConfigManager) {
    this.configManager = configManager;
  }
  
  async createFromConfig(configPath: string): Promise<ChatAgent> {
    const config = await this.configManager.loadFromFile(configPath);
    return this.createAgent(config);
  }
  
  async createFromYAML(yamlString: string): Promise<ChatAgent> {
    const config = await this.configManager.loadFromYAML(yamlString);
    return this.createAgent(config);
  }
  
  private createAgent(config: AgentConfig): ChatAgent {
    // Determinar tipo de agente baseado na configuração
    let agent: ChatAgent;
    
    if (config.vectorStores && config.vectorStores.length > 0) {
      agent = new RAGAgent(config, new OpenAIEmbedder());
    } else if (config.persistence) {
      agent = new PersistentAgent(config);
    } else {
      agent = new ChatAgent(config);
    }
    
    // Registrar tools
    if (config.tools) {
      for (const toolConfig of config.tools) {
        if (toolConfig.enabled !== false) {
          const tool = this.loadTool(toolConfig);
          agent.registerTool(tool);
        }
      }
    }
    
    // Configurar persistência
    if (config.persistence && agent instanceof PersistentAgent) {
      agent.setPersistence(config.persistence);
    }
    
    // Configurar vector stores
    if (config.vectorStores && agent instanceof RAGAgent) {
      for (const storeConfig of config.vectorStores) {
        agent.addVectorStore(storeConfig.name, storeConfig);
      }
    }
    
    return agent;
  }
  
  private loadTool(toolConfig: ToolConfig): Tool {
    switch (toolConfig.type) {
      case 'builtin':
        return this.loadBuiltinTool(toolConfig.name);
      case 'custom':
        return this.loadCustomTool(toolConfig.path!);
      case 'external':
        return this.loadExternalTool(toolConfig.url!);
      default:
        throw new Error(`Tipo de tool não suportado: ${toolConfig.type}`);
    }
  }
  
  private loadBuiltinTool(toolName: string): Tool {
    // Importar tool builtin
    const builtinTools = {
      calculator: calculatorTool,
      datetime: dateTimeTool,
      weather: weatherTool
    };
    
    const tool = builtinTools[toolName];
    if (!tool) {
      throw new Error(`Tool builtin não encontrada: ${toolName}`);
    }
    
    return tool;
  }
  
  private loadCustomTool(toolPath: string): Tool {
    // Carregar tool customizada
    const toolModule = require(toolPath);
    return toolModule.default || toolModule;
  }
}
```

## Exemplos de Uso

### 1. Criação de Agente via Configuração

```typescript
const factory = new AgentFactory(new YAMLConfigManager());

// Criar agente a partir de arquivo YAML
const agent = await factory.createFromConfig('./configs/research-agent.yaml');

// Usar o agente
const response = await agent.sendMessage('Qual é o estado atual da pesquisa em IA?');
console.log('Resposta:', response);
```

### 2. Templates e Herança

```yaml
# base-agent.yaml
name: "Agente Base"
instructions: "Você é um assistente útil"
provider: "openai-generic"
temperature: 0.7
tools:
  - name: "calculator"
    type: "builtin"
    enabled: true

# specialized-agent.yaml
extends: "./base-agent.yaml"
name: "Agente Especializado"
instructions: "Você é um assistente especializado em finanças"
tools:
  - name: "financial_calculator"
    type: "custom"
    path: "./tools/finance.js"
    enabled: true
```

### 3. Configuração com Variáveis de Ambiente

```yaml
# production-agent.yaml
name: "Agente de Produção"
instructions: "Você é um assistente para ambiente de produção"
provider: "openai"
model: "${OPENAI_MODEL}"
temperature: 0.3

persistence:
  backend: "postgresql"
  connectionString: "${DATABASE_URL}"
  autoSave: true

vectorStores:
  - name: "knowledge_base"
    type: "pinecone"
    apiKey: "${PINECONE_API_KEY}"
    indexName: "${PINECONE_INDEX_NAME}"
    dimension: 1536
```

## Considerações de Implementação

### 1. Validação
- Schema validation rigorosa
- Validação de tipos e valores
- Mensagens de erro claras

### 2. Segurança
- Sanitização de inputs
- Validação de paths de arquivos
- Controle de acesso a recursos

### 3. Performance
- Caching de configurações
- Parsing otimizado
- Resolução eficiente de variáveis

### 4. Extensibilidade
- Suporte a formatos adicionais
- Plugins para validação customizada
- Hooks para pré/pós processamento

## Próximos Passos

1. Implementar protótipo do YAMLConfigManager
2. Criar SchemaValidator
3. Desenvolver AgentFactory
4. Testar cenários de configuração complexa
5. Adicionar suporte a herança de configurações
6. Implementar caching de configurações
7. Documentar padrões de uso e boas práticas