# Plano de Substituição do BAML

## Motivação

Após análise aprofundada, identificamos que a dependência do BAML impede a criação de um SDK verdadeiramente reutilizável:

1. **Limitação de Tools Dinâmicas**: O BAML exige que todas as tools sejam definidas estaticamente em arquivos `.baml`, o que é incompatível com a necessidade de tools definidas dinamicamente pelos usuários do SDK.
2. **Complexidade de Abstração**: Tentar abstrair o TypeBuilder do BAML tornaria o SDK mais complexo do que soluções existentes.
3. **Incompatibilidade com SDK Reutilizável**: O modelo estático do BAML é excelente para aplicações monolíticas, mas não para bibliotecas genéricas.

## Objetivos da Substituição

1. **Criar um SDK reutilizável** que permita aos usuários definir tools dinamicamente
2. **Manter type safety** através de bibliotecas como Valibot
3. **Preservar funcionalidades existentes** como configuração dinâmica, validação de schemas, etc.
4. **Manter compatibilidade com múltiplos providers** (OpenAI, Anthropic, etc.)

## Arquitetura Proposta (Sem BAML)

### Nova Estrutura de Camadas

```
SDK do Agente
│
├── Camada de Abstração
│   ├── Adaptação de Providers
│   ├── Prompt Engineering
│   └── Validação de Schemas
│
├── Sistema de Tools
│   ├── Registro Dinâmico
│   ├── Validação de Parâmetros (Valibot)
│   └── Execução
│
├── Gerenciamento de Contexto
│   ├── Histórico de Mensagens
│   └── Memória de Curto Prazo
│
└── Configuração
    ├── Parâmetros Dinâmicos
    └── Perfis de Configuração
```

### Componentes Principais

#### 1. Sistema de Tools Dinâmico

```typescript
// Interface de Tool Padrão
interface Tool {
  name: string;
  description: string;
  parameters?: ValibotSchema;
  execute: (args: any) => Promise<any>;
}

// Registro de Tools
class ToolRegistry {
  register(tool: Tool): void;
  get(name: string): Tool | undefined;
  list(): Tool[];
  unregister(name: string): boolean;
}
```

#### 2. Validação com Valibot

Substituir schemas BAML por schemas Valibot:

```typescript
// Antigo (BAML)
// class StructuredResponse {
//   answer string
//   confidence float
// }

// Novo (Valibot)
import * as v from 'valibot';

const StructuredResponseSchema = v.object({
  answer: v.string(),
  confidence: v.number([v.minValue(0), v.maxValue(1)]),
  reasoning: v.optional(v.string())
});
```

#### 3. Adaptação de Providers

Implementar adaptadores para diferentes providers:

```typescript
interface ProviderAdapter {
  sendMessage(params: SendMessageParams): Promise<SendMessageResponse>;
  sendStructuredMessage(params: SendStructuredMessageParams): Promise<any>;
  supportsTools(): boolean;
  supportsStreaming(): boolean;
}

class OpenAIAdapter implements ProviderAdapter {
  // Implementação específica para OpenAI
}

class AnthropicAdapter implements ProviderAdapter {
  // Implementação específica para Anthropic
}
```

#### 4. Prompt Engineering Dinâmico

```typescript
class PromptBuilder {
  buildChatPrompt(messages: Message[], tools?: Tool[]): string;
  buildToolPrompt(tool: Tool): string;
  buildStructuredPrompt(schema: any): string;
}
```

## Migração Passo a Passo

### Fase 1: Camada de Abstração

1. **Criar interfaces de abstração** para providers
2. **Implementar adaptadores** para OpenAI e Anthropic
3. **Mover configuração dinâmica** para a nova arquitetura

### Fase 2: Sistema de Tools

1. **Substituir ToolRegistry** com validação Valibot
2. **Implementar execução de tools** sem dependência do BAML
3. **Criar sistema de registro dinâmico** de tools

### Fase 3: Validação de Schemas

1. **Substituir schemas BAML** por schemas Valibot
2. **Implementar validação automática** de respostas
3. **Criar helpers para definição de schemas** no SDK

### Fase 4: Prompt Engineering

1. **Criar sistema de templates** para prompts
2. **Implementar injeção dinâmica** de tools nos prompts
3. **Adicionar suporte a context window** management

## Benefícios da Nova Arquitetura

1. **Reutilizabilidade**: SDK pode ser usado por qualquer desenvolvedor para criar agentes personalizados
2. **Flexibilidade**: Tools podem ser definidas dinamicamente em runtime
3. **Simplicidade**: Menos dependências e camadas de abstração
4. **Type Safety**: Valibot oferece DX similar ao Pydantic
5. **Performance**: Menos overhead de geração de código

## Considerações de Compatibilidade

1. **API Pública**: Manter a mesma interface pública do SDK
2. **Exemplos**: Atualizar exemplos para usar a nova arquitetura
3. **Documentação**: Reescrever documentação para refletir a nova abordagem
4. **Testes**: Manter cobertura de testes equivalente

## Cronograma Estimado

1. **Fase 1 (Camada de Abstração)**: 3-5 dias
2. **Fase 2 (Sistema de Tools)**: 4-6 dias
3. **Fase 3 (Validação de Schemas)**: 3-4 dias
4. **Fase 4 (Prompt Engineering)**: 3-5 dias
5. **Testes e Documentação**: 3-4 dias

## Próximos Passos

1. Criar branch `feature/remove-baml` para desenvolvimento
2. Iniciar implementação da camada de abstração de providers
3. Configurar ambiente de desenvolvimento com Valibot
4. Criar testes unitários para a nova arquitetura
